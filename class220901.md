# OT - 유길상 교수님 
1. 앞으로의 강의 계획
-- 4개월 간 이론, 프로그래밍, 프로젝트를 모두 끝내야함
2. 수상받은 프로젝트 사례들
-- 최대한 많은 사람들이 쓸 수 있는 앱?을 목표로 할 것


# class am - 문근영 선생님
##파이썬 기본
    a = 1 
왼쪽 항은 name space or identifier으로 부름. 그 이유는 파이썬의 특징 중 하나인 타입을 선언하지 않고 변수를 넣고 그 타입으로 알아서 설정됨
일부 name은 미리 정해진 타입 및 변수가 있다. - keyword
    keyword.kwlist
    len(keyword.kwlist) -> 36개가 있다.

error
name error - 이름을 붙일 수 없는 것에 이름을 붙이려 할 경우
syntax error - 문법에 맞지 않는 경우

이름 명명법 -  
- snake 방식 - 두 단어를 중간에 '__' 를 이용해 붙인다. function에 붙인다. steam_library 
- camel 방식 - 두 단어 중 뒷 단어를 대문자로 사용 - steamLibrary
- pascal/capsword - 두 단어 모두 대문자로 사용 - class에 붙인다. -SteamLibrary

네이버 면접 질문 pep8은 무엇인가
PEP 8 - Python Enhancement Proposals 파이썬 코딩 스타일 가이드

이름에 숫자로 시작하는 문자는 쓸 수 없다. 
    1a = 1 -> systaxs error

"이름 =" Assignment or Binding: 할당
	import antigravity - 파이선의 자료형 할당이 자유롭다는 것을 표현
내부적으로 '=' 뒤에 값(타입)에 따라 알아서 할당
Literals - data type을 표현하는 특수문자
없으면 정수, [] list, {} tuple 등등

id(이름): 이름의 주소가 나옴
type(이름): 이름의 타입이 나옴

"= expression" : 식 또는 표현식 - 연산 결과에 의해 하나의 표현으로 reduction가능한 문장
파이썬에서 function은 first class function으로 부르고 "=" 다음에 올 수 있다.

data : 0101 기계어 그 자체
value : 기계어의 해석된 결과 - type을 다르게 두면 value가 바뀜


## 숫자형 타입 4가지 - Int, float, complex, bool - 정수, 부동소수, 복소수, true/false
builtins : 기본적으로 사용할 수 있는 것들 - 타입명 포함됨
파이선에서 int의 최대값이 존재하는데 그보다 더 큰 수를 할당해도 알아서 더 큰 범위의 int로 바꿔준다 - 무한대까지 가능
-> 타입을 알아서 바꿔주는게 개발 경험을 좋지만 속도를 느리게 한다 - 수치해석에 부적합한 언어

### int의 4가지 표현 : 기본이 10진법
	0b010
	0b3 -> syntax error : 2진법에 어긋남
	0b : 2진법
	0o : 8진법
	0x : 16진법

### float : 부동소수 - 소수에는 부동소수와 고정소수가 있다. 파이선에서 부동소수만 씀.
컴퓨터는 0과 1로만 데이터를 표현하기에 소수를 완벽하게 나타낼 수 없다. 근사값을 - 부동소수, 고정소수의 문제가 발생
	0.1 +0.1+ 0.1 => 0.300000004
부동 소수처리하는 룰 IEEE754
프로그래밍에서 float은 연속이다고 처리함 - 미분가능 - 무한대의 개념이 들어가 있다.
부동 소수의 가장 큰 값
	sys.float_info
부동 소수의 최대값 근처에서는 inf: 무한대 처리함
	a = 1e+308
	a == a+1
	a*10 => inf

소수로 만들어주는 literal "."
	.3 => 0.3
	3. => 3.0
	1e1 => 10.0 : 10^1

연산 속도는 int가 float보다 빠르다

nan : Not a number 파이선에서는 float으로 처리
	float('nan') => nan

### complex : 복소수 
	1j*1j => -1+0j

### boolean : True == 1 / False == 0
	type(True).__base__
	issubclass(bool, int) => True - 다른 데이터 타입임에도 서로 연산이 되는 경우

coercion (코어션)
같은 형의 두 인자를 수반하는 연산이 일어나는 동안, 한 형의 인스턴스를 다른 형으로 묵시적으로 변환하는 것. 예를 들어, int(3.15)는 실수를 정수 3으로 변환합니다. 하지만, 3+4.5 에서, 각 인자는 다른 형이고 (하나는 int, 다른 하나는 float), 둘을 더하기 전에 같은 형으로 변환해야 합니다. 그렇지 않으면 TypeError를 일으킵니다. 코어션 없이는, 호환되는 형들조차도 프로그래머가 같은 형으로 정규화해주어야 합니다, 예를 들어, 그냥 3+4.5 하는 대신 float(3)+4.5

2 / 3 => 0.66666
2 // 3 => 0
2 % 3 => 1

-2 // 3 => -1 
-0.6666666 => -1 + 0.3333333
2 % -3 => -1

round : 반올림하는 함수
round(1.5) => 2
round(2.5) => 2 - 실수를 정확히 표현 불가능하기 때문에
round(-1.5) => -2
round(-2.5) => -2

decimal : 정확한 소수를 계산할 때 씀, fractions - ML은 정확한 값을 계산하는 게 아니라 추측하는거라 필요없음

atomic : 숫자는 각 자리별로 쪼갤수 없다. 반대말로 쓸 수 있는 개념이 container : 여러개를 나눌 수 있는 거
다른 문자형은 쪼갤 수 있다.

	a = 'abcd'
	len(a) => 4

container :
  homo : 같은 데이터 타입만 담을 수 있는 경우. tensorflow는 data로 homo ex)문자열 'abcd' / hetero ex) List [1, 2, '3']
  sequence : indexing과 sliceing이 가능한 데이터 타입. 순서가 명확하다. sequence data type끼리 더할 수 있다.  ex) List / nonsequence ex) Dict
    b = [1,2,4] + [3,4,5] => [1,2,4,3,4,5]
    b = [1,2,4]*4 = [1,2,4,1,2,4,1,2,4,1,2,4]
  mutable / immutable


## 문자 - str bytes, bytearray, memoryview
	str u'abcd' // 기본은 유니코드 문자열이고 그냥 쓰면 됨
	bytes b'abcd' // 아스키코드만 가능. 모든 문자열의 subset이기에 웹으로 전송하는 파일 등에 사용

### List : squence hetero mutable type 변형가능한 타입

파이선은 상수가 없다. 
	a = 1
	a = 2
	a => 2
다시 선언하면 재할당하여 값이 바뀜

값을 재할당해도 주소가 바뀌지 않는 data type이 mutable
	a = [1,2,3]
	id(a)
	a.append(4)
	id(a)

### tuple : squence hetero immutable type - record, istance, data 변형되면 안되는 값을 저장할때 사용
	b = 1,2
	b = (1,2)

mutable data의 문제 - 얕은 복사, 깊은 복사
	c = d = [1,2]
	c.append(3)
	c => [1,2,3]
	d => [1,2,3]
하나만 바꿔도 같이 바뀐다
	c = d = [[1,2],[3,4]]
	c[0][0] = 200
	d => [[200,2],[3,4]]

	e = [1,2]
	f = e
	f[0] = 100
	e => [100,2]
	e.copy()

이 상황을 처리하기 위한 방법
	x = [1,2,3]
	x[:] => [1,2,3]
	
	import copy
	f = copy.deepcopy(e)

	a,b = 1,2 => a,b = (1,2)
	b,a = a,b => (b,a) = (a,b) 
	a => 2
	b => 1

	*a, b = 1,2,3
	a => [1,2]
	b => 3

duck-typing (덕 타이핑)
 올바른 인터페이스를 가졌는지 판단하는데 객체의 형을 보지 않는 프로그래밍 스타일; 대신, 단순히 메서드나 어트리뷰트가 호출되거나 사용됩니다 (“오리처럼 보이고 오리처럼 꽥꽥댄다면, 그것은 오리다.”) 특정한 형 대신에 인터페이스를 강조함으로써, 잘 설계된 코드는 다형적인 치환을 허락함으로써 유연성을 개선할 수 있습니다. 덕 타이핑은 type() 이나 isinstance() 을 사용한 검사를 피합니다. (하지만, 덕 타이핑이 추상 베이스 클래스 로 보완될 수 있음에 유의해야 합니다.) 대신에, hasattr() 검사나 EAFP 프로그래밍을 씁니다. 

### set : hetero nonsequence mutable
frozenset : hetero nonsequence immutable
set에는 mutable한 data를 넣을 수 없다. 중복이 안되고 순서가 내부적으로 강제됨.
	a = {1,1,1,2,2,2}
	a => {1,2}

	a = {1,2,[3]}
	typeError : unhashable type 모든 구성물에 mutable한 data가 없음

### Dictionary : key, value로 이루어진 mutable data
	{'a':1, 'a':2} => {'a': 2}
중복되면 가장 마지막 것으로 됨
	1 in {'a':1, 'b':2} => False
	for i in {'a':1, 'b':2}
		print(i)
	=> a
	   b


## class pm DBMS 류기군 선생님 - 관계형 DB
### 데이터베이스 개요
data를 DB(Hadoop, spark)에 저장해서 통계를 이용해 분석해서 model화 한다. 그런데 현대는 다루는 data의 크기가 상상을 초월해서 그 자체를 다루는 것이 어려워짐. 
관계형 DB을 앞으로 공부하게 될것
데이터 전체중 80%가 비정형 데이터이다. 영상, 자연어처리-텍스트, 음성
데이터 레이크 하우스로 통째로 다 모으는 것이 요즘 대세

data base - dbms
특정 조건에 맞춰서 정리된 데이터의 모음, 그리고 그것을 관리하는 시스템

data : 처리되지 않은 자료의 모음
-text, numbers, images, audio, video

information : 처리된(계산된) 데이터
-documents, audio, images, video

db의 특징
-실시간 접근성
-계속적인 변화 
-동시 공유 가능
-내용에 의한 참조 가능

dbms : 데이터베이스들을 관리하고 사용자 설정 등 관리를 용이하게 해주는 시스템
-create databases
-insert, update and delete data
-sort and query data
-create form and report

dbms의 종류
-계층형 모델
-네트워크형 모델
-관계데이터 모델 - mysql, mariadb, postgre 등등
-객체 관계 모델(ORM)

RDMS : 관계형 데이터베이스 매니저 시스템
데이터 안정성 safety
동시 접근성 cocurrent access
장애 허용성 fault tolerance - 롤백해서 복구함
데이터 무결성 integrity
데이터 확장성 scalability
데이터 보고서 reporting

RDMS concepts
relation - table
tuple - row or record
attribute - column or field
cardinality - Number of rows
Degree - number of columns
domain - pool or legal values
prime key - unique identifier


### 데이터베이스 설계
개체 관계 모델(Entity-Relationship Model)
개체 (entity) : 실 세계에 존재하는 분리된 실체 하나를 표현, 일반적으로 명사 하나에 해당
관계 (relationship) : 개체들 사이에 존재하는 연관이나 연결, 일반적으로 동사에 해당, 최대 대응수와 최소 대응수로 구성
속성 (attribute) : 개체의 성질, 분류, 식별, 수량, 상태 등을 나타내느 세부 항목, 관계또한 속성을 보유할 수 있음
기본키 (primary key) : 모든 개체를 고유하게 식별할 수 있는 속성


### SQL
Structured Query Language
 RDBMS의 데이터를 관리하기 위해 만들어진 언어

명령
-정의 CREATE DROP ALTER TRUNCATE
-조작 INSERT UPDATE DELETE SELECT
-제어 GRANT REVOKE

data type
-boolean
-character (CHAR, VARCHAR)
-Exact numeric (NUMERIC, DECIMAL, INTERGER, SMALLINT, BIGINT)
-Approximate numeric (REAL, FLOAT, DOUBLE)
-Datetime (DATE, TIME, TIMESTAMP) / Large Object

#### DDL : data definition language
-CREATE : db 생성
 --constraints
	NOT NULL
	UNIQUE
	PRIMARY KEY : NOT NULL and UNIQUE
-DROP : db 삭제
-TRUNCATE : db의 값만 날리고 틀은 남게됨
-ALTER : db의 구조를 바꿀 때 사용, column 추가 삭제 수정 등

#### DML : 데이터 조작어
-INSERT
-SELECT * : ALL, DISTINCT : 중복 제거한 전부
-LIKE find a string fitting a certain description / % wildcard
-UPDATE : where 절을 조심해서 쓰지 않으면 싹 바뀜
-DELETE : 특정 row를 지움

### SQLite